import { GoogleGenAI } from "@google/genai";
import type { ScpData, ScpInfo } from '../types';

if (!process.env.API_KEY) {
  throw new Error("API_KEY environment variable not set");
}

const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });

const extractScpInfo = async (scpId: string): Promise<ScpInfo> => {
    const fields = ['name', 'class', 'containment', 'description'];
    
    const prompt = `
      Access the content of the webpage at https://scp-wiki.wikidot.com/${scpId}.
      From the page, extract the following data points precisely: ${fields.join(', ')}.
      - For 'name' or 'item #', extract the primary designation.
      - For 'class', extract the object class (e.g., Safe, Euclid, Keter).
      - For 'containment', summarize the special containment procedures.
      - For 'description', provide a concise summary of the SCP's description.
      The combined summary for containment and description should be no more than 4-5 sentences total.
      Return ONLY a raw JSON object with keys "name", "class", "containment", and "description". If a field is not found, use "N/A" as the value. Do not wrap the JSON in markdown code blocks.
    `;

    try {
        const response = await ai.models.generateContent({
            model: 'gemini-2.5-flash',
            contents: prompt,
            config: {
                tools: [{googleSearch: {}}],
            },
        });

        let jsonText = response.text.trim();
        // The model might still return markdown, so we try to extract it.
        const markdownMatch = jsonText.match(/```(?:json)?\s*([\s\S]+?)\s*```/);
        if (markdownMatch) {
            jsonText = markdownMatch[1];
        }
        
        const parsedData = JSON.parse(jsonText);
        
        return {
            name: parsedData.name || "N/A",
            class: parsedData.class || "N/A",
            containment: parsedData.containment || "N/A",
            description: parsedData.description || "N/A",
        };
    } catch (error) {
        console.error('Error calling Gemini API for data extraction:', error);
        throw new Error('Failed to extract SCP information from the wiki.');
    }
};

const generateImagePromptForSCP = async (scpName: string): Promise<string> => {
    try {
        const prompt = `You are an expert on the SCP Foundation, tasked with creating safe-for-work, artistic image prompts based on SCP entries from the official SCP Wiki (scp-wiki.wikidot.com). Your goal is to create a visually descriptive prompt for an AI image generator for ${scpName}. The final image should be realistic and detailed, like a cinematic still or a high-quality digital painting. It should be evocative, hinting at the anomaly's nature without any explicit or implied violence, gore, harm, suffering, nudity, or offensive content. Focus on creating a mysterious, atmospheric, and believable scene. Avoid any words or descriptions that could be interpreted as violent, scary, or unsettling. The prompt should be a single paragraph of text only, and must not mention the SCP designation. Describe the scene, subject, and environment with rich, safe-for-work imagery that feels grounded in reality.`;

        const response = await ai.models.generateContent({
            model: 'gemini-2.5-flash',
            contents: prompt,
            config: {
              tools: [{googleSearch: {}}],
            },
        });

        return response.text;
    } catch (error) {
        console.error("Error generating image prompt:", error);
        throw new Error("Failed to generate a descriptive prompt for the image.");
    }
};

const generateImageFromPrompt = async (prompt: string): Promise<string> => {
    try {
        const response = await ai.models.generateImages({
            model: 'imagen-4.0-generate-001',
            prompt: prompt,
            config: {
                numberOfImages: 1,
                outputMimeType: 'image/jpeg',
                aspectRatio: '1:1',
            },
        });

        if (response.generatedImages && response.generatedImages.length > 0) {
            const base64ImageBytes = response.generatedImages[0].image.imageBytes;
            return `data:image/jpeg;base64,${base64ImageBytes}`;
        } else {
            throw new Error("No image was generated by the API. It may have been blocked for safety reasons.");
        }
    } catch (error) {
        console.error("Error generating image:", error);
        if (error instanceof Error && error.message.includes("Responsible AI practices")) {
             throw new Error("Image generation was blocked due to safety filters. The generated prompt may have contained sensitive terms.");
        }
        throw new Error("Failed to generate the final image.");
    }
};


export const generateScpDataAndImage = async (scpId: string): Promise<ScpData> => {
    // Run info extraction and descriptive prompt generation in parallel
    const [info, descriptivePrompt] = await Promise.all([
        extractScpInfo(scpId),
        generateImagePromptForSCP(scpId)
    ]);

    // Generate the final image using the descriptive prompt
    const imageUrl = await generateImageFromPrompt(descriptivePrompt);

    return {
        ...info,
        imageUrl,
    };
};

export const generateColumnMapping = async (tableColumns: string[]): Promise<Record<string, string>> => {
    const scpDataFields = ['name', 'class', 'containment', 'description', 'imageUrl'];
    const prompt = `
        You are an intelligent database mapping assistant.
        I have data about an SCP entry with the following fields: ${JSON.stringify(scpDataFields)}.
        I need to save this data into a database table with these columns: ${JSON.stringify(tableColumns)}.
        
        Your task is to create a JSON object that maps my data fields (as keys) to the most appropriate table columns (as values).
        - The keys of the JSON object MUST be from my list of fields.
        - The values of the JSON object MUST be from the list of available table columns.
        - For my 'imageUrl' field, look for columns named 'image_url', 'image', 'url', or similar.
        - If you cannot find a suitable match for a field, omit it from the mapping.
        
        Return ONLY the raw JSON mapping object. Do not include any other text or markdown wrappers.
    `;

    try {
        const response = await ai.models.generateContent({
            model: 'gemini-2.5-flash',
            contents: prompt,
            config: {
                responseMimeType: "application/json",
            },
        });

        const jsonText = response.text.trim();
        const parsedMapping = JSON.parse(jsonText);

        // Validate the mapping to ensure it only contains valid keys and values
        const validatedMapping: Record<string, string> = {};
        for (const key in parsedMapping) {
            if (scpDataFields.includes(key) && tableColumns.includes(parsedMapping[key])) {
                validatedMapping[key] = parsedMapping[key];
            }
        }
        return validatedMapping;

    } catch (error) {
        console.error('Error calling Gemini API for column mapping:', error);
        throw new Error('Failed to generate column mapping with AI.');
    }
};